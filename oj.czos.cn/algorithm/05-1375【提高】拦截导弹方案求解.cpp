/*1375 - 【提高】拦截导弹方案求解
题目描述
某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：
虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。
某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。
输入n个导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。
比如：有8颗导弹，飞来的高度分别为
389  207  175  300  299  170  158  165
那么需要2个系统来拦截，他们能够拦截的导弹最优解分别是：
系统1：拦截 389  207 175 170 158
系统2：拦截 300  299 165

输入
两行，第一行表示飞来导弹的数量n（n<=1000）
第二行表示n颗依次飞来的导弹高度（导弹高度互不相等）

输出
第一行输出：要拦截所有导弹最小配备的系统数k
接下来k行分别输出每套系统拦截哪些高度的导弹

样例
输入
8
389  207  175  300  299  170  158  165
输出
2
1:389 207 175 170 158
2:300 299 165
来源
贪心 vector

标签
贪心vector
*/
#include <bits/stdc++.h>
using namespace std;
// n:代表导弹数量,x:代表每个导弹的高度
int n, x;
int i, j, p;
// r[i][0]代表第i套系统拦截了几个导弹
// r[i][r[i][0]]代表第i套系统拦截的最后一个导弹的高度
//也就是该系统能够拦截的最高高度
int r[1010][1010];  //存储第i套系统拦截的导弹的高度
int k;              //代表开了几套系统，也就是r数组的下标

int main() {
  cin >> n;
  //读入导弹的高度
  for (i = 1; i <= n; i++) {
    cin >> x;
    //代表能拦截的系统的下标
    //假设没有系统能拦截
    p = -1;
    //循环所有的系统，查找能拦截的第一套系统
    for (j = 1; j <= k; j++) {
      if (r[j][r[j][0]] >= x) {
        p = j;
        break;
      }
    }

    //判断如果有系统能拦截
    if (p != -1) {
      r[p][0]++;  //拦截数量+1
      //将第i个导弹的高度存储到r[p]这一行
      r[p][r[p][0]] = x;
    } else {
      k++;
      r[k][0] = 1;
      r[k][1] = x;  // r[k][r[k][0]] = x;
    }
  }

  //系统数量
  cout << k << endl;
  for (i = 1; i <= k; i++) {
    cout << i << ":";  //输出系统编号
    //输出导弹的高度
    for (j = 1; j <= r[i][0]; j++) {
      cout << r[i][j] << " ";
    }
    cout << endl;
  }
  return 0;
}