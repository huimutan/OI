## 7.3回溯
回溯是搜索算法中的一种控制策略。 它的基本思想是：为了求得问题的解， 先选择一种可能情况向前探索，在探索过程中， 一旦发现原来的选择是错误的， 就退回一步重新选择，继续向前搜索，如此反复进行， 直至得到解或证明无解。
如迷宫问题：进入迷宫后， 先随意选择一个前进方向， 一步步向前试探前进，如果碰到死胡同，说明前进方向已无路可走，这时，首先看其它方向是否还有路可走， 如果有路可走，则沿该方向再向前试探；如果已无路可走， 则返回一步， 再看其它方向是否还有路可走；如果有路可走，则沿该方向再向前试探。 按此原则不断搜索回溯再搜索， 直到找到新的出路或从原路返回入口处无解为止。
**//实现思路一**

```CPP
int search(int k){
    for(i = 1;i <= 算法总数；i++){
        if（满足条件）{
            保存结果；
            if（到目的地）{
                输出解；
            }else{
                search(k + 1);
            }
            恢复：保存结果之前的状态，回溯一步；
        }
    }
}
```
**//实现思路二**

```CPP
int search(int k){
    if（到目的地）{
	    输出解；
    }else{
        for(i = 1;i <= 算符种数；i++){
            if（满足条件）{
                保存结果；
                search(k + 1);
                恢复：保存结果之前的状态；//回溯一步
            }
        }
    }
}
```

### 一、回溯案例
#### 1739:【基础】迷宫的所有路径

![20220809_080832_067](07.3%E3%80%81%E5%9B%9E%E6%BA%AF/20220809_080832_067.png)

解法1：

```CPP
/*1739 - 【基础】迷宫的所有路径
题目描述
已知一N×N的迷宫，允许往上、下、左、右四个方向行走，且迷宫中没有任何障碍，所有的点都可以走。现请你按照右、下、左、上顺序进行搜索，找出从左上角到右下角的所有路径。

输入
输入一个整数N（N<=5）代表迷宫的大小。

输出
按右、下、左、上搜索顺序探索迷宫，输出从左上角1,1点走到右下角N,N点的所有可能的路径。

样例
输入
3
输出
1:1,1->1,2->1,3->2,3->3,3
2:1,1->1,2->1,3->2,3->2,2->3,2->3,3
3:1,1->1,2->1,3->2,3->2,2->2,1->3,1->3,2->3,3
4:1,1->1,2->2,2->2,3->3,3
5:1,1->1,2->2,2->3,2->3,3
6:1,1->1,2->2,2->2,1->3,1->3,2->3,3
7:1,1->2,1->2,2->2,3->3,3
8:1,1->2,1->2,2->3,2->3,3
9:1,1->2,1->2,2->1,2->1,3->2,3->3,3
10:1,1->2,1->3,1->3,2->3,3
11:1,1->2,1->3,1->3,2->2,2->2,3->3,3
12:1,1->2,1->3,1->3,2->2,2->1,2->1,3->2,3->3,3
来源
回溯

标签
回溯
*/
#include <bits/stdc++.h>
using namespace std;
//右、下、左、上
/*
思路：沿着右、下、左、 上的顺序深度优先搜索， 走过的点标记为true
递归其他方向，递归结束， 后退到上一步，撤销标记， 回溯到前一个状态
*/
int n, c;
int r[30][3];    //存储路径
bool f[10][10];  //标记点是否走过
int fx[5] = {0, 0, 1, 0, -1};
int fy[5] = {0, 1, 0, -1, 0};
//输出路径
void print(int k) {
  c++;
  cout << c << ":";
  for (int i = 1; i < k; i++) {
    cout << r[i][1] << "," << r[i][2] << "->";
  }
  cout << n << "," << n << endl;
}
//深搜存储路径： 将 xy 点存储到 r 数组下标为 k 的位置
void dfs(int x, int y, int k) {
  r[k][1] = x;
  r[k][2] = y;
  //如果到了终点，打印
  if (x == n && y == n) {
    print(k);
    return;
  }
  //尝试不同的方向
  int tx, ty;
  for (int i = 1; i <= 4; i++) {
    tx = x + fx[i];
    ty = y + fy[i];
    //判断新的方向可达，且没有访问过
    if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && f[tx][ty] == false) {
      //标记tx,ty点走过了
      f[tx][ty] = true;
      dfs(tx, ty, k + 1);
      //递归结束，后退，回溯到前一个状态
      f[tx][ty] = false;
    }
  }
}
int main() {
  cin >> n;
  //从1,1点开始递归，记录到 r数组下标为1的那一行
  f[1][1] = true;  //标记1,1点走路
  dfs(1, 1, 1);
  return 0;
}
```

解法2：

```CPP
#include <bits/stdc++.h>
using namespace std;
//右、下、左、上
/*
思路：沿着右、下、左、 上的顺序深度优先搜索， 走过的点标记为true
递归其他方向，递归结束，后退到上一步， 撤销标记，回溯到前一个状态
*/
int n, c;
int r[30][3];    //存储路径
bool f[10][10];  //标记点是否走过
int fx[5] = {0, 0, 1, 0, -1};
int fy[5] = {0, 1, 0, -1, 0};
//输出路径
void print(int k) {
  c++;
  cout << c << ":";
  for (int i = 1; i < k; i++) {
    cout << r[i][1] << "," << r[i][2] << "->";
  }
  cout << n << "," << n << endl;
}
//深搜存储路径： 将 xy 点存储到 r 数组 下标为k的位置
void dfs(int k) {
  //尝试不同的方向
  int tx, ty;
  for (int i = 1; i <= 4; i++) {
    tx = r[k - 1][1] + fx[i];
    ty = r[k - 1][2] + fy[i];
    //判断新的方向可达，且没有访问过
    if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && f[tx][ty] == false) {
      //存储路径
      r[k][1] = tx;
      r[k][2] = ty;
      //标记 tx,ty 点走过
      f[tx][ty] = true;
      //如果到了终点
      if (tx == n && ty == n) {
        print(k);
      } else {
        dfs(k + 1);
      }
      //递归结束，回溯到前一个状态
      f[tx][ty] = false;
    }
  }
}
int main() {
  cin >> n;
  //存储第1个点
  r[1][1] = 1;
  r[1][2] = 1;
  f[1][1] = true;  //标记1,1点走路
  //从r数组下标为 2 的那一行开始存储路径
  dfs(2);
  return 0;
}
```



1308 - 【基础】全排列的结果

```CPP
/*1308 - 【基础】全排列的结果
题目描述
从键盘读入一个整数n（n<=6），请输出1~n中所有整数的全排列，按照由小到大输出结果，每组的n个数之间用空格隔开。
全排列的含义：从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。
如当n=3时，全排列的结果为：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1

输入
一个整数n（n >= 1 && n <= 6）

输出
1~n中所有数的全排列的结果，按照由小到大输出，每行n个数

样例
输入
3
输出
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
来源
回溯

标签
回溯排列组合
*/
#include <bits/stdc++.h>
using namespace std;
int n;
int a[10];   //存放全排列的结果
bool f[10];  //标记哪些数使用过
void print() {
  for (int i = 1; i <= n; i++) {
    cout << a[i];
    if (i != n)
      cout << " ";
    else
      cout << endl;
  }
}
//递归函数：为a数组每个元素赋值
void fun(int k) {
  for (int i = 1; i <= n; i++) {
    //如果i这个数没有被使用过，则填写到下标为k的位置
    if (f[i] == false) {
      a[k] = i;
      f[i] = true;  //标记数字i被选用了
      //如果a中存储了n个元素，输出结果，否则递归，为k+1的下标赋值
      if (k == n) {
        print();
      } else {
        fun(k + 1);
      }
      f[i] = false;  //回溯到前一个状态，标记i没有使用过
    }
  }
}
int main() {
  cin >> n;
  fun(1);
  return 0;
}

```



#### 1358 - 【提高】素数环

素数环：从1到n这n个数摆成一个环， 要求相邻的两个数的和是一个素数。
从1开始，每个空位有 n 种可能性， 只要填进去的数合法（与前面的数不相同， 与左边相邻的数的和是一个素数）。
第n 个数还要判断和第一个数的和是否是素数。
算法思路：
第一步：数据初始化
第二步：递归填数，判断第i 个数填入是否合法
a、如果合法：填数：判断是否到达目标 (20 个已填完)：是，打印结果：不是， 递
归填下一个；
b、如果不合法：选择下一种可能；


```CPP
/*1358 - 【提高】素数环
题目描述
从1~n（2<=n<=10）这n个数，摆成一个环，要求相邻的两个数的和是素数，按照由小到大请输出所有可能的摆放形式。

比如：n = 4，输出形式如下

1:1 2 3 4

2:1 4 3 2
3:2 1 4 3
4:2 3 4 1
5:3 2 1 4
6:3 4 1 2
7:4 1 2 3
8:4 3 2 1
total:8

比如：n = 6，输出形式如下

1:1 4 3 2 5 6
2:1 6 5 2 3 4
3:2 3 4 1 6 5
4:2 5 6 1 4 3
5:3 2 5 6 1 4
6:3 4 1 6 5 2
7:4 1 6 5 2 3
8:4 3 2 5 6 1
9:5 2 3 4 1 6
10:5 6 1 4 3 2
11:6 1 4 3 2 5
12:6 5 2 3 4 1
total:12

输入
一个整数n（2<=n<=10）

输出
前若干行，每行输出一个素数环的解，最后一行，输出解的总数

样例
输入
4
输出
1:1 2 3 4
2:1 4 3 2
3:2 1 4 3
4:2 3 4 1
5:3 2 1 4
6:3 4 1 2
7:4 1 2 3
8:4 3 2 1
total:8
来源
回溯

标签
回溯排列组合
*/
#include <bits/stdc++.h>
using namespace std;
/*
将n 个数全排列，且要求相邻的数的和是素数
（第一个数和最后一个数算相邻）
思路：从1~n 中， 选数填到 a 数组的下标为k的位置
从 k=1 开始填写，直到 k==n，也就是 a数组填满
填写的过程中， 要求相邻的数的和是素数
*/
int a[20];   //存放选数的结果
bool f[20];  //标记每个数是否被用过
int n, c;
//素数判断
bool prime(int n) {
  for (int i = 2; i * i <= n; i++) {
    if (n % i == 0) {
      return false;
    }
  }
  if (n == 1) return false;
  return true;
}
//输出结果
void print() {
  c++;
  cout << c << ":";
  for (int i = 1; i <= n; i++) {
    cout << a[i];
    if (i != n) {
      cout << " ";
    } else {
      cout << endl;
    }
  }
}
//递归选数的函数
void fun(int k) {
  //下标为k的位置，有 n 种选法
  for (int i = 1; i <= n; i++) {
    //如果 i 没有被选过，且 i 和前一个数的和是素数
    //&&:如果第 1 条件为 false, 第 2 条件不判断，结果直接为 false
    //||:如果第 1 条件为 true, 第 2 条件不判断，结果直接为 true
    if (f[i] == false && (k == 1 || prime(i + a[k - 1]) == true)) {
      a[k] = i;     //将选中的数填入数组
      f[i] = true;  //标记 i 用过了
      //如果元素的数量足够了， 且最后一个数和第一个数的和是素数， 则打印
      if (k == n && prime(a[k] + a[1])) {
        print();
      } else {
        //递归向 k+1 的位置存值
        fun(k + 1);
      }
      //回溯：撤销 i 用过的标记
      f[i] = false;
    }
  }
}
int main() {
  cin >> n;
  //从 a 数组下标为 1 的位置开始选数
  fun(1);
  cout << "total:" << c;
}
```



