/*1386 - 【基础】小丽找半个回文数？
题目描述
小丽同学在编程中学到了回文数的概念，如果一个数正过来读和反过来读是同一个数，那么这个数就是回文数；比如：2、5、8、66、121、686、12321都是回文数，小丽发现，这样的数不算多。于是小丽有个想法，如果这个数不是回文数，但这个数在2进制或者16进制下是回文数，就算这个整数是半个回文数，比如417并不是回文，但417对应的16进制数是1A1是回文数，因此417算半个回文数。
请你编程帮助小丽找符合条件的半个回文数。

输入
第一行是一个整数n（10<=n<=100）
第二行是n个整数（这些整数都是0~108之间的整数）

输出
所有符合条件的半个回文数，每行一个。

样例
输入
5
121 417 27 100 21
输出
417
27
21
来源
进制转换

标签
进制转换
*/
#include <bits/stdc++.h>
using namespace std;
/*
如果这个数在10进制下不是回文数
但这个数在2进制或者16 进制下是回文数
*/
/*
判断整数n在d进制下是否是回文
除d对d取余数，将余数存入数组， 判断数组是否是回文
*/
bool huiwen(int n, int d) {
  bool r = true;      //假设是回文
  int a[1000] = {0};  //初始化为0，存n转 d进制后的每一位
  int k = 0;
  while (n != 0) {
    a[k] = n % d;
    k++;
    n /= d;
  }
  //判断回文：循环数组长度一半， 判断对称位置是否有不等
  for (int i = 0; i < k / 2; i++) {
    if (a[i] != a[k - i - 1]) {
      r = false;
      break;
    }
  }
  return r;
}
int main() {
  int a[110], n, i;
  cin >> n;
  for (i = 0; i < n; i++) {
    cin >> a[i];
  }
  //遍历每个数，判断是否是半个回文
  for (i = 0; i < n; i++) {
    if (huiwen(a[i], 10) == false &&
        (huiwen(a[i], 2) == true || huiwen(a[i], 16) == true)) {
      cout << a[i] << endl;
    }
  }
}
