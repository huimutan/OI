/*1383 - 【提高】奶牛和草丛
题目描述
奶牛Bessie计划好好享受柔软的春季新草。新草分布在R行C列的牧场里。它想计算一下牧场中的草丛数量。
在牧场地图中，每个草丛要么是单个“#”，要么是有公共边的相邻多个“#”。给定牧场地图，计算有多少个草丛。
例如，考虑如下5行6列的牧场地图
.#....
..#...
..#..#
....##
.....#
这个牧场有3个草丛：一个在第一行，一个在第二列横跨了二、三行，一个在第三行横跨了三、四、五行。

输入
第一行包含两个整数R和C，中间用单个空格隔开。
接下来R行，每行C个字符，描述牧场地图。字符只有“#”或“.”两种。(1 <= R, C <= 100 )

输出
输出一个整数，表示草丛数。

样例
输入
5 6
.#....
..#...
..#..#
....##
.....#
输出
3
来源
深搜 递归

标签
深搜递归
*/
#include <bits/stdc++.h>
using namespace std;
char a[33][33];
int n, m;
void dfs(int x, int y) {
  a[x][y] = '.';  //改变值来记录已经搜索过的#
  if (a[x + 1][y] == '#') dfs(x + 1, y);
  if (a[x - 1][y] == '#') dfs(x - 1, y);
  if (a[x][y + 1] == '#') dfs(x, y + 1);
  if (a[x][y - 1] == '#') dfs(x, y - 1);
  return;
}

int main() {
  cin >> n >> m;
  int tot = 0;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) cin >> a[i][j];
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
      if (a[i][j] == '#') {
        tot++;      //找到#，累计加1
        dfs(i, j);  //  搜索相邻的 #
      }
    }
  cout << tot;
  return 0;
}