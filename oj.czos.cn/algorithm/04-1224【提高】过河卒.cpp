/*1224 - 【提高】过河卒
题目描述
A 点有一个过河卒，需要走到目标 B
点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如下图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如下图
C 点可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。
棋盘用坐标表示，现给定A 点位置为（0,0）B 点位置为（n,m）(n,m 为不超过 10
的整数)，马的位置为C（X,Y）（约定:
C点与A点不重叠，与B点也不重叠）。要求你计算出卒从 A 点能够到达 B
点的路径的条数。

输入
B点的坐标（n,m）以及对方马的坐标（X,Y）（马的坐标一定在棋盘范围内，但要注意，可能落在边界的轴上）

输出
样例
输入
6 6 3 2
输出
17
来源
递推

标签
递推
*/
#include <bits/stdc++.h>
using namespace std;
/*
将棋盘所有值设置为 1
标记马及马的控制点为0
a[0][0]不需要计算，除此以外
i=0，第 1 行，除了控制点， a[i][j]等于左侧的值
j=0，第 1 列，除了控制点， a[i][j]等于上方的值
其余的点，除了控制点， a[i]=左侧+上方的值
*/
int main() {
  int a[30][30];  //存放棋盘的值，默认初值都为 0
  int n, m, x, y, i, j;
  cin >> n >> m >> x >> y;
  //将棋盘所有值设为1
  for (i = 0; i <= n; i++) {
    for (j = 0; j <= m; j++) {
      a[i][j] = 1;
    }
  }
  //设置马及马的控制点为 0
  a[x][y] = 0;
  //如果控制点在棋盘内，则设置为 0
  if (x - 1 >= 0 && y - 2 >= 0) a[x - 1][y - 2] = 0;
  if (x - 2 >= 0 && y - 1 >= 0) a[x - 2][y - 1] = 0;
  if (x - 2 >= 0 && y + 1 <= m) a[x - 2][y + 1] = 0;
  if (x - 1 >= 0 && y + 2 <= m) a[x - 1][y + 2] = 0;
  if (x + 1 <= n && y + 2 <= m) a[x + 1][y + 2] = 0;
  if (x + 2 <= n && y + 1 <= m) a[x + 2][y + 1] = 0;
  if (x + 2 <= n && y - 1 >= 0) a[x + 2][y - 1] = 0;
  if (x + 1 <= n && y - 2 >= 0) a[x + 1][y - 2] = 0;
  // for (i = 0; i <= n; i++) {
  // for (j = 0; j <= m; j++) {
  // cout << a[i][j] << "";
  // }
  // cout << endl;
  //}
  //递推计算
  for (i = 0; i <= n; i++) {
    for (j = 0; j <= m; j++) {
      if (i == 0 && j == 0) {
        //略过本次循环下方的语句直接开始 下一个循环
        continue;
      }
      //马的控制点不需要计算
      if (a[i][j] == 0) {
        continue;
      }
      //如果是第1行
      if (i == 0) {
        a[i][j] = a[i][j - 1];
        // 每个点的值 = 左侧的值
      } else if (j == 0) {
        //第 1 列，每个点的值 = 上方的值
        a[i][j] = a[i - 1][j];
      } else {
        //其余点(不包括第1行第1列及马的控制点)
        a[i][j] = a[i][j - 1] + a[i - 1][j];
      }
    }
  }
  cout << a[n][m];
}