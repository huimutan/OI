/*1532 - 【提高】小X与神牛
题目描述
神牛都长着B只角，B只角从左到右在头顶上排成一排。每只角上都标着数字，不是0就是1。
小X将每头神牛的B只角上的数字从左到右依次取出，组成一个只含0或1的B位二进制数。
小X将这个二进制数转化为十进制，用这个十进制数来代表一头神牛，这个十进制就是这头神牛的编号。
神牛们之间的关系是很微妙的，如果两头神牛的第i只角上的数字不同，则称这两头神牛的第i只角是不一样的。
如果两头神牛不同的角的数目大于等于D，则称这两头神牛是友好的。比如当B=8，D=2时，
01010100
00110100
  xx
这两头神牛的第2和第3只角不同(x指向的位置)，不同的角的数目为2，所以这两头神牛是友好的。
现在小X向你求助：请找出N头神牛，使得任意两头神牛都是友好的，并将这N头神牛的编号按从小到大排序后依次输出。如果有多种符合条件的解，那么排在越前面的牛的编号越小越好。

输入
输入仅有一行包含3个用空格隔开的正整数，分别表示 N, B, D。

输出
输出仅有一行包含N个非负整数，相邻两个数之间用一个空格隔开，表示N头神牛的编号。如果有多解，你的程序要输出这样的解：越前面的牛的编号越小越好。

样例
输入
3 5 3
输出
0 7 25
说明
样例输入
样例1:
3 5 3
样例2:
16 7 3
样例输出
样例1:
0 7 25
样例2:
0 7 25 30 42 45 51 52 75 76 82 85 97 102 120 127
样例解释
每头神牛都长着7只角，若两头神牛不同的角的数目大于等于3，则这两头神牛是友好的。现在要找出16头相互都友好的神牛。
答案是0000000, 0000111, 0011001, 0011110, 0101010, 0101101, 0110011, 0110100,
1001011, 1001100, 1010010, 1010101, 1100001, 1100110, 1111000,
1111111，转化为十进制就是0 7 25 30 42 45 51 52 75 76 82 85 97 102 120 127
数据规模
对于30%的数据，1<=D<=B<=8，1<=N<=3
对于另外10%的数据，D=1
对于另外30%的数据，D=2
对于100%的数据，1<=D<=B<=8, 1<=N<=16
数据保证有解。

来源
常州市2017“信息与未来”夏令营选拔赛

来源
市赛

标签
市赛
*/
#include <bits/stdc++.h>
using namespace std;
// 数字转二进制
string numTo2(int n, int b) {
  string res = "";
  while (n) {
    res = char(n % 2 + '0') + res;
    n /= 2;
  }
  int len = b - res.size();
  for (int i = 1; i <= len; i++) {
    res = "0" + res;
  }
  return res;
}
// 判断字符串s,是否符合要求
bool check(string s, string a[], int b, int d, int len) {
  // 判断字符串是否已在数组中,返回假
  for (int i = 0; i < len; i++) {
    if (a[i] == s) {
      return false;
    }
  }

  // 如果不在数组中
  // 遍历每个字符串,判断s是否满足要求(有d个字符不相等).
  /* 条件:依次和a数组中的每个数据作比较,比较不相同的字符个数
                  如果有一次不相同的字符的个数不满足,则这个字符串不满足条件
  */
  for (int i = 0; i < len; i++) {
    // 判断不相同的字符的个数
    int x = 0;
    for (int j = 0; j < b; j++) {
      if (a[i][j] != s[j]) {
        x++;
      }
    }
    // 有一次不满足,返回假
    if (x < d) {
      return false;
    }
  }
  // 上述条件都不成立,返回真
  return true;
}
// 字符串转数字
int sToNum(string s) {
  int num = 0;
  int p = 1;
  for (int i = s.size() - 1; i >= 0; i--) {
    num += (s[i] - '0') * p;
    p *= 2;
  }
  return num;
}
int main() {
  string a[20], cmp, s2;
  int n, b, d, num = 1, count = 1, p = 1, i, j, k, now;
  //	cout<<numTo2(4,5);
  cin >> n >> b >> d;
  for (i = 1; i <= b; i++) {
    num *= 2;
  }
  a[0] = numTo2(0, b);
  for (i = 0; i < num; i++) {
    // 每个i二进制和数组里面的数作比较
    // 计算字符串数组中元素的个数
    int len = sizeof(a) / sizeof(a[0]);
    // 需要判断的字符串
    s2 = numTo2(i, b);
    // 如果符合要求,把字符串放入数组中
    if (check(s2, a, b, d, len)) {
      a[p] = s2;
      p++;
      count++;
    }
    // 当个数满足要求,退出比较
    if (count == n) {
      break;
    }
  }
  // 输出数组中满足条件的值
  for (i = 0; i < p; i++) {
    cout << sToNum(a[i]) << " ";
  }
  return 0;
}