/*1434 - 【基础】数池塘（四方向）
题目描述
农夫约翰的农场可以表示成N*M（1≤N≤100≤M≤100）个方格组成的矩形。由于近日的降雨，在约翰农场上的不同地方形成了池塘。每一个方格或者有积水（'W'）或者没有积水（'.'）。农夫约翰打算数出他的农场上共形成了多少池塘。一个池塘是一系列相连的有积水的方格，每一个方格周围的四个方格都被认为是与这个方格相连的。现给出约翰农场的图样，要求输出农场上的池塘数。

输入
第1行：由空格隔开的两个整数：N和M
第2..N+1行：每行M个字符代表约翰农场的一排方格的状态。每个字符或者是'W'或者是'.'，字符之间没有空格。

输出
输出只有1行，输出约翰农场上的池塘数

样例
输入
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
输出
13
来源
深搜 递归

标签
深搜递归
*/
#include <bits/stdc++.h>
using namespace std;
/*
思路：当遇到积水格，计数器加 1, 并将该区域的池塘抽干
*/
int n, m;
char a[110][110];  //默认初值为'\0'
int fx[5] = {0, 0, 1, 0, -1};
int fy[5] = {0, 1, 0, -1, 0};
//深搜：将xy及相邻的积水点全部标记为 .
void dfs(int x, int y) {
  //将递归到的有效的点（相邻的有积水的点 标记为。
  a[x][y] = '.';
  int tx, ty;
  //递归尝试4个方向
  for (int i = 1; i <= 4; i++) {
    tx = x + fx[i];
    ty = y + fy[i];
    //如果该点有效(本题判断相邻格是W, 就不用判断是否出边界了)
    if (a[tx][ty] == 'W') {
      dfs(tx, ty);
    }
  }
}
int main() {
  cin >> n >> m;
  int i, j, c = 0;
  //读入地图
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= m; j++) {
      cin >> a[i][j];
    }
  }
  //依次遍历每个点，如果是池塘， 就将计数器+1, 并将相邻池塘单元格全部标记为点
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= m; j++) {
      //如果该点是池塘
      if (a[i][j] == 'W') {
        c++;
        dfs(i, j);
      }
    }
  }
  cout << c;
}