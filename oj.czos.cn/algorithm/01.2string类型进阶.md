## 四、string进阶问题

### 4.1 string进阶问题课堂训练

1.
1100:【入门】词组缩写

![20220603_020658_275](01.2string%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6/20220603_020658_275.png)

每个单词有一个或多个大写或小写字母组成由一个或多个空格分隔这些单词
end of file
end of file
   end Of File
End of File

第一步：找出每个单词的首字母首字母：
(1)如果是第一个字符且不是空格(不是第一个字符&&s[订当前字符不是空格&&s[i-1]上一个字符是空格)
(2)s=“ ”+s;
从第2个字符开始循环，如果当前字符不是空格&&上一个字符是空格，则是首字母！
第二步：如果是小写转大写

```CPP
/*1100 - 【入门】词组缩写
题目描述
定义：一个词组中每个单词的首字母的大写组合称为该词组的缩写。
比如，C语言里常用的EOF就是end of file的缩写。
输入
测试数据占一行，有一个词组，每个词组由一个或多个单词组成；
每组的单词个数不超过10个，每个单词有一个或多个大写或小写字母组成；
单词长度不超过10，由一个或多个空格分隔这些单词。

输出
输出规定的缩写

样例
输入
end of file
输出
EOF
来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  string s;
  int i;
  //读入字符串
  getline(cin, s);
  s = " " + s;
  //其余字符，如果当前字符不是空格且上个字符是空格是首字母
  for (i = 1; i < s.size(); i++) {
    //如果是首字母
    if (s[i] != ' ' && s[i - 1] == ' ') {
      cout << (char)toupper(s[i]);
    }
  }
  return 0;
}

```



#### 1103:【基础】字符串压缩

![20220603_020631_641](01.2string%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6/20220603_020631_641.png)

思路：采用数数的思想，数出连续相同的字符有几个！

c=0
每遇到一个字符，c++，并判断连续的字符是否结束，如果结束，输出字符及出现的次数，并清空计数器！
if(到了最后一个字符 || 当前字符s[i]！=下一个字符s[i+1] ){

}
if(i =s.size（）-1 || s[i]!=s[i+1]){
}



```CPP
/*1103 - 【基础】字符串压缩
题目描述
输入字符串，输出压缩后的字符串。压缩的方法是把连续的相同字母压缩为"长度+字母"的形式，在本题中，单个的字母不需要压缩。

输入
一行，一个字符串,只包含小写英文字母,长度不超过255。

输出
样例
输入
aaabbbbbx
输出
3a5bx
来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  string s;
  int i, c = 0;
  cin >> s;
  for (i = 0; i < s.size(); i++) {
    c++;
    //如果连续相同字符结束了
    if (i == s.size() - 1 || s[i] != s[i + 1]) {
      if (c != 1) {
        cout << c << s[i];
      } else {
        cout << s[i];
      }
      c = 0;
    }
  }
}
```



3.

1012: 【基础】我是第几个单词

![20220603_030601_530](01.2string%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6/20220603_030601_530.png)

第一步：分解出字符串中的每个单词，并输出每个单词是第几个单词如果当前字符不是空格，则一定是单词的一部分(不含最后的。)，存入w

{
每存入一个字符，就判断连续字符是否结束（下一个字符是空格 || 下一个字符是。）{
如果连续字符结束，输出W,清空w用来存放下一个单词；}
}
This is a Book.

This 1  is 2  a 3  Book 4

```CPP
/*1012 - 【基础】我是第几个单词
题目描述
输入一个英文句子，例如：“This is a Book."，可以看到句子是以“.”来作为结束符号的，
并且单词之间以一个空格来分隔。接着再输入一个单词A，请找出首次在句子中出现的与A相同的单词，
是句子中的第几个单词，若不存在，则输出该句子中单词字符的总个数。
例如对上句子而言，若输入单词“is”，则应输出：2 若输入单词“isa”，则应输出：11

输入
第一行为以‘.’结束的一个词组（仅由若干个单词组成，单词间由一空格隔开，
除单词和最后的“.”以外，不含其它字符）
第二行是一个单词（不含空格）
输出
一个整数

样例
输入
This is a Book.
Book
输出
4
来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
/*
以“.”来作为结束符号
并且单词之间以一个空格来分隔
找句子中首次出现的单词A
*/
string s, w, t;
int i, c = 0;
int main() {
  getline(cin, s);  //读入字符串
  //遍历每个字符
  for (i = 0; i < s.size() - 1; i++) {
    //如果当前字符不是空格，则一定是单词的一部分
    if (s[i] != ' ') {
      w = w + s[i];
      //判断单词是否结束
      if (s[i + 1] == ' ' || s[i + 1] == '.') {
        c++;  //单词个数计数器
        cout << w << " " << c << endl;
        w = "";
      }
    }
  }
  return 0;
}

```

第二步：逐个判断每个单词是否是要找的单词，如果是输出位置并break,如果找不到要找的单词，则输出字符总数！

```CPP
#include <bits/stdc++.h>
using namespace std;
/*
以“.”来作为结束符号
并且单词之间以一个空格来分隔
找句子中首次出现的单词A
*/
string s, w, t;
int i, c = 0, c2 = 0;
bool f;  //标记是否找到过要找的单词
int main() {
  getline(cin, s);  //读入字符串
  cin >> t;         //读入要找的单词
  //遍历每个字符
  for (i = 0; i < s.size() - 1; i++) {
    //如果当前字符不是空格，则一定是单词的一部分
    if (s[i] != ' ') {
      w = w + s[i];
      //判断单词是否结束
      if (s[i + 1] == ' ' || s[i + 1] == '.') {
        c++;  //单词个数计数器
        // cout << w << " " << c << endl;
        //把每个单词的长度加到总字符个数上
        c2 += w.size();
        if (w == t) {
          cout << c;
          f = true;
          break;
        }
        w = "";
      }
    }
  }
  //如果没有找到过该单词
  if (f = false) {
    cout << c2;
  }
  return 0;
}

```



4.

1123:【基础】表达式的值

![20220603_030650_661](01.2string%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6/20220603_030650_661.png)

思路：
第一步：分解并输出每个连续的数字
12
234
58

第二步：将每个连续的数字转换为整数，加到总和上



```CPP
/*1123 - 【基础】表达式的值
题目描述
给出一个表达式,其中运算符仅包含+,要求求出表达式的最终值。
如：1+1，则结果为2，1+2+3则结果为6，12+23则结果35。

输入
仅一行，即为含有正整数和+号的表达式。
输出
仅一行，既为表达式算出的结果（所有数据保证计算结果<=109）。

样例
输入
1+1
输出
2
来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
string s, w;  //存放表达式
int x, r, i;
int main() {
  cin >> s;
  for (i = 0; i < s.size(); i++) {
    //如果当前字符是数字,则是连续数字的一部分
    if (isdigit(s[i])) {
      w += s[i];
      //判断连续数字是否结束
      // !表示取反, isdigit() 表示是数字,!isdigit() 表示不是数字
      if (i == s.size() - 1 || !isdigit(s[i + 1])) {
        // cout<<w<<endl;
        r += stoi(w);  //将字符串转换为整数
        w = "";        //清空连续数字,存放下一个数字
      }
    }
  }
  cout << r;
}
```



5.

#### 1127 - 【基础】整数的拼接

```CPP
/*1127 - 【基础】整数的拼接
题目描述
设有n个整数(3≤n≤100)，将这些整数拼接起来，可以形成一个最大的整数。
例如：n=3，三个整数分别为21 7 34， 拼接后最大的整数为： 73421
再比如：n=3，三个整数分别是1 10 110，拼接后最大的整数是：111010

输入
第一行一个整数n ，表示有n 个整数。
第二行n个整数，数与数之间用一个空格分隔。

输出
输出到屏幕 。一个拼接后的最大的整数。

样例
输入
3
21 7 34
输出
73421
来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
// s1="10"s2="1"
// s1+s2>s2+s1
// 110>181
// 1 110 10
bool cmp(string s1, string s2) {
  if (s1 + s2 > s2 + s1) {
    return true;
  } else {
    return false;
  }
}
string s[110];
int i, n;
int main() {
  cin >> n;
  for (i = 0; i < n; i++) {
    cin >> s[i];
  }
  sort(s, s + n, cmp);
  //输出排序的结果
  for (i = 0; i < n; i++) {
    cout << s[i];
  }
}
```



6.

#### 1336：【提高】分数计算
思路：
第一步：定义函数求出两个整数的最大公约数

辗转相除法，求最大公约数！
反复使用a%b,如果a%b==0,则b就是最大公约数，如果a%b!=0,a取b的值，b取余数的值！
a%b=8%12=8
12%8=4
东方博宜青少年编程
8%4=0
求a和b最小公倍数，先求出最大公约数为t,最小公倍数=a*b/t;
第二步：模拟分数计算的过程直接计算
分解分子、分母，进行计算，然后约分，判断特殊情况（分子是分母的倍数）

解法一：将分数表达式作为字符串读入，然后模拟计算
```CPP
/*1336 - 【提高】分数计算
题目描述
从键盘读入一个分数算式，为2个分数做加法或者减法，请输出分数算式的结果，结果也用分数表达，且约分到最简形式。（请注意：做减法可能得到负的分数，如果是负数要输出负号-，如1/15-4/15结果为-1/5）（5.1.76）

输入
分数表达式；分数表达式中，每个分数的分子和分母都是正整数（不超过1000），两个分数中的运算符，可能是加号，也可能是减号，且分数表达式不含空格；

输出
分数表达式计算的结果；

样例
输入
1/12+5/12
输出
1/2
说明
注意考虑特殊情况,如:1/2+1/2=1,1/2-1/2=0,这些情况下结果不需要表现为分数形式。

来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
//定义函数，求最大公约数
int gys(int a, int b) {
  int t;
  while (a % b != 0) {
    t = a % b;
    a = b;
    b = t;
  }
  return b;
}
// s:表达式
// s1:左边的分数，s2:右边的分数
// fz1,fm1:第一个分数的分子分母
string s, s1, s2, fz1, fm1, fz2, fm2;
//整数存放分子和分母
int a1, b1, a2, b2;
int p;       //存放运算符+或-的下标
int r1, r2;  //存放计算结果的分子和分母
int t;
int main() {
    cin >> s;
    // 1/12+5/12
    p = s.find("+");
    //说明是减法运算
    if (p == -1) {
      p = s.find("-");
    }
    s1 = s.substr(0, p);
    s2 = s.substr(p + 1);
    // cout<<s1<<""<<s2;
    // 1/12
    fz1 = s1.substr(0, s1.find("/"));
    fm1 = s1.substr(s1.find("/") + 1);
    fz2 = s2.substr(0, s2.find("/"));
    fm2 = s2.substr(s2.find("/") + 1);
    // cout<<fz1<<" "<<fm1<<endl<<fz2<<" "<<fm2;
    a1 = stoi(fz1);
    b1 = stoi(fm1);
    a2 = stoi(fz2);
    b2 = stoi(fm2); 
  //计算结果的分母
  r2 = b1 * b2;
  //计算结果的分子
  if (s.find("+") != -1) {
    r1 = a1 * b2 + a2 * b1;
  } else {
    r1 = a1 * b2 - a2 * b1;
    if (r1 < 0) {
      cout << "-";
      r1 = r1 * -1;
    }
  }
  // cout<<r1<<"/"<<r2;
  t = gys(r1, r2);
  //如果分子是分母的倍数，则直接除掉
  if (r1 % r2 == 0) {
    cout << r1 / r2;
  } else {
    cout << r1 / t << "/" << r2 / t;
  }
}

```

解法二：根据分数表达式的特性，直接读入分子和分母，简化截取分子、分母及转换分
子、分母的过程

```CPP
/*1336 - 【提高】分数计算
题目描述
从键盘读入一个分数算式，为2个分数做加法或者减法，请输出分数算式的结果，结果也用分数表达，且约分到最简形式。（请注意：做减法可能得到负的分数，如果是负数要输出负号-，如1/15-4/15结果为-1/5）（5.1.76）

输入
分数表达式；分数表达式中，每个分数的分子和分母都是正整数（不超过1000），两个分数中的运算符，可能是加号，也可能是减号，且分数表达式不含空格；

输出
分数表达式计算的结果；

样例
输入
1/12+5/12
输出
1/2
说明
注意考虑特殊情况,如:1/2+1/2=1,1/2-1/2=0,这些情况下结果不需要表现为分数形式。

来源
字符串

标签
字符串
*/
#include <bits/stdc++.h>
using namespace std;
//定义函数，求最大公约数
int gys(int a, int b) {
  int t;
  while (a % b != 0) {
    t = a % b;
    a = b;
    b = t;
  }
  return b;
}
// s:表达式
// s1:左边的分数，s2:右边的分数
// fz1,fm1:第一个分数的分子分母
string s, s1, s2, fz1, fm1, fz2, fm2;
//整数存放分子和分母
int a1, b1, a2, b2;
int p;       //存放运算符+或-的下标
int r1, r2;  //存放计算结果的分子和分母
int t;
char c, f;  //方法2读入数据-----------------
int main() {
  /*   cin >> s;
    // 1/12+5/12
    p = s.find("+");
    //说明是减法运算
    if (p == -1) {
      p = s.find("-");
    }
    s1 = s.substr(0, p);
    s2 = s.substr(p + 1);
    // cout<<s1<<""<<s2;
    // 1/12
    fz1 = s1.substr(0, s1.find("/"));
    fm1 = s1.substr(s1.find("/") + 1);
    fz2 = s2.substr(0, s2.find("/"));
    fm2 = s2.substr(s2.find("/") + 1);
    // cout<<fz1<<" "<<fm1<<endl<<fz2<<" "<<fm2;
    a1 = stoi(fz1);
    b1 = stoi(fm1);
    a2 = stoi(fz2);
    b2 = stoi(fm2); */
  cin >> a1 >> c >> b1 >> f >> a2 >> c >> b2;  //方法2读入数据-----------------
  //计算结果的分母
  r2 = b1 * b2;
  //计算结果的分子
  //   if (s.find("+") != -1) {
  if (f == '+') {
    //方法2判断----------------------
    r1 = a1 * b2 + a2 * b1;
  } else {
    r1 = a1 * b2 - a2 * b1;
    if (r1 < 0) {
      cout << "-";
      r1 = r1 * -1;
    }
  }
  // cout<<r1<<"/"<<r2;
  t = gys(r1, r2);
  //如果分子是分母的倍数，则直接除掉
  if (r1 % r2 == 0) {
    cout << r1 / r2;
  } else {
    cout << r1 / t << "/" << r2 / t;
  }
}

```





### 4.2 string进阶问题作业训练
1106:【入门】统计单词个数
1111:【基础】找最长单词
1107:【基础】 求英文句子中的最长单词
1113:【基础】隐藏的最大整数
1104:【基础】字符串解压
1132:【入门】保留整数
1122:【基础】计算表达式
1124:【基础】表达式的值II
1339:【提高】求多个分数的和
