/*1374 - 【基础】摘花生问题（2）
题目描述
Hello
Kitty又一次来到花生地里摘花生，从左上角进入花生地，从右下角出去，只能向右或者向下，请问Hello
Kitty应该沿着什么样的路线走，能够摘到的花生数量最多（假设花生地里没有任何2株的花生一样多，也不存在多条路线能够摘到一样多的花生的情况）？
比如输入：
2 2
1 2
3 4
应该输出：1-3-4，也就是按照1 3 4这三株数量的花生摘过去，能够摘到最多的花生！

输入
第一行是2个整数m和n（2≤m,n≤=100），代表花生地有m行，n列花生！
后面m行，每行有n个整数代表了每行中，每株花生的数量。

输出
输出Hello Kitty按照走过的路线中，摘到每株花生的数量。

样例
输入
2 2
1 2
3 4
输出
1-3-4
来源
递推

标签
递推
*/

#include <bits/stdc++.h>
using namespace std;
int a[110][110], r[210];
int main() {
  int m, n, i, j;
  cin >> m >> n;
  for (i = 1; i <= m; i++) {
    for (j = 1; j <= n; j++) {
      cin >> a[i][j];
    }
  }
  //数组通过计算存储当前累计的最大值：当前最大值= 当前值 +
  //(左边值和上面值中的较大值)
  for (i = 1; i <= m; i++) {
    for (j = 1; j <= n; j++) {
      a[i][j] += max(a[i][j - 1], a[i - 1][j]);
    }
  }

  //仿照数塔问题，倒过来计算路线
  int x = m, y = n;  //终点
  //一共经过n+m-1个点
  for (int i = 1; i <= n + m - 1; i++) {
    //如果从左侧来
    if (a[x][y - 1] > a[x - 1][y]) {
      r[i] = a[x][y] - a[x][y - 1];
      y--;  //让x,y到左侧
    } else {
      //从上方来
      r[i] = a[x][y] - a[x - 1][y];
      x--;
    }
  }

  //输出结果
  for (int i = n + m - 1; i >= 1; i--) {
    cout << r[i];
    if (i != 1) {
      cout << "-";
    }
  }
  return 0;
}
