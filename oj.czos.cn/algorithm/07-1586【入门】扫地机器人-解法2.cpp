/*1586 - 【入门】扫地机器人
题目描述
Mike同学在为扫地机器人设计一个在矩形区域中行走的算法，Mike是这样设计的：先把机器人放在出发点(1,1)点上，机器人在每个点上都会沿用如下的规则来判断下一个该去的点是哪里。规则：优先向右，如果向右不能走（比如：右侧出了矩形或者右侧扫过了）则尝试向下，向下不能走则尝试向左，向左不能走则尝试向上；直到所有的点都扫过。

Mike为了验证自己设计的算法是否正确，打算先模拟一下这个算法，每当机器人走过一个单元格时，会在单元格内标记一个数字，这个数字从1开始，每经过一个单元格数字会递增1，直到所有的单元格都扫一遍，也就是所有的单元格都标记过数字，机器人会自动停止。
比如：如果机器人按照上面的规则，清扫一个3 *
4大小的矩形区域，那么标记数字的结果如下图所示。


再比如：如果机器人按照上面的规则，清扫一个5 *
5大小的矩形区域，那么标记数字的结果如下图所示。

请你帮助Mike设计一个程序，按照上面的规则，将一个n *
m大小的矩形，标记一下数字，输出最终标记的结果。

输入
一行内有2个两个整数n和m，用空格隔开，分别代表矩形区域的行数（高）和列数（宽）（n和m都是2~9之间的整数）

输出
输出按题意机器人走过每个点之后，标记数字的结果，每个数字输出时场宽设置为3。

样例
输入
3 4
输出
  1  2  3  4
 10 11 12  5
  9  8  7  6
来源
深搜

标签
深搜
*/

#include <bits/stdc++.h>
using namespace std;
int n, m;
int a[20][20];
//为二维数组赋值
//为x,y点赋值为k
void fun(int x, int y, int k) {
  //由于每 次递归前没有检验递归的点是有效点
  //因此可能xy 是无效的(出了边界的点， 或者已经赋值的点)
  if (x >= 1 && x <= n && y >= 1 && y <= m && a[x][y] == 0) {
    a[x][y] = k;  //赋值
    //优先向右，其次向下，再次向左，再次向上
    //向右尝试
    fun(x, y + 1, k + 1);
    //向下尝试
    fun(x + 1, y, k + 1);
    //向左尝试
    fun(x, y - 1, k + 1);
    //向上尝试
    fun(x - 1, y, k + 1);
  }
}
int main() {
  // n行m列
  cin >> n >> m;
  //为 1,1 点赋值为 1
  fun(1, 1, 1);
  //输出
  int i, j;
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= m; j++) {
      cout << setw(3) << a[i][j];
    }
    cout << endl;
  }
}