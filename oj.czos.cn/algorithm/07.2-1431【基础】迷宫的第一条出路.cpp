/*1431 - 【基础】迷宫的第一条出路
题目描述
已知一N×N的迷宫，允许往上、下、左、右四个方向行走，现请你按照左、上、右、下顺序进行搜索，找出第一条从左上角到右下角的路径。

输入
输入数据有若干行，第一行有一个自然数N（N≤20），表示迷宫的大小，其后有N行数据，每行有N个0或1（数字之间没有空格，0表示可以通过，1表示不能通过），用以描述迷宫地图。入口在左上角（1，1）处，出口在右下角（N，N）处。所有迷宫保证存在从入口到出口的可行路径。

输出
输出数据仅一行，为按照要求的搜索顺序找到的从入口到出口的第一条路径（搜索顺序：左、上、右、下）。

样例
输入
4
0001
0100
0010
0110
输出
(1,1)->(1,2)->(1,3)->(2,3)->(2,4)->(3,4)->(4,4)
来源
深搜 递归

标签
深搜递归
*/
#include <bits/stdc++.h>
using namespace std;
//左、上、右、下顺序进行搜索
char a[30][30];
int r[410][3];  //记录正确的第一条路径
int n;
//方向的变化
int fx[5] = {0, 0, -1, 0, 1};
int fy[5] = {0, -1, 0, 1, 0};
//打印 r 数组中存储的第一条路线
void print(int k) {
  for (int i = 1; i <= k; i++) {
    cout << "(" << r[i][1] << "," << r[i][2] << ")";
    //如果不是最后一个点，打印连接的->
    if (i != k) {
      cout << "-> ";
    }
  }
  exit(0);  //停止程序
}
//向路径数组下标为k 的位置， 记录一个坐标x,y
void dfs(int x, int y, int k) {
  //记录探索到的点的坐标
  r[k][1] = x;
  r[k][2] = y;
  //将走过的点，标记为 1，防止死循环
  a[x][y] = '1';
  //判断 xy 如果是终点，则打印路径
  if (x == n && y == n) {
    print(k);
  }
  int tx, ty;
  //探索四个方向
  for (int i = 1; i <= 4; i++) {
    tx = x + fx[i];
    ty = y + fy[i];
    //如果该点可达(没走过，且不是障碍， 且没有出迷宫)
    if (a[tx][ty] == '0') {
      //向 r 数组的下标为 k+1 那一行， 记录tx,ty点
      dfs(tx, ty, k + 1);
    }
  }
}
int main() {
  int i, j;
  cin >> n;
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      cin >> a[i][j];
    }
  }
  //调用函数，探索出第一条路径
  //向r数组的下标为 1 的那一行， 记录1,1点
  dfs(1, 1, 1);
}