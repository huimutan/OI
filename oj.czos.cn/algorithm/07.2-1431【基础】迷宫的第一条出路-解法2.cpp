/*1431 - 【基础】迷宫的第一条出路
题目描述
已知一N×N的迷宫，允许往上、下、左、右四个方向行走，现请你按照左、上、右、下顺序进行搜索，找出第一条从左上角到右下角的路径。

输入
输入数据有若干行，第一行有一个自然数N（N≤20），表示迷宫的大小，其后有N行数据，每行有N个0或1（数字之间没有空格，0表示可以通过，1表示不能通过），用以描述迷宫地图。入口在左上角（1，1）处，出口在右下角（N，N）处。所有迷宫保证存在从入口到出口的可行路径。

输出
输出数据仅一行，为按照要求的搜索顺序找到的从入口到出口的第一条路径（搜索顺序：左、上、右、下）。

样例
输入
4
0001
0100
0010
0110
输出
(1,1)->(1,2)->(1,3)->(2,3)->(2,4)->(3,4)->(4,4)
来源
深搜 递归

标签
深搜递归
*/
//解法二：通过数组记录走过的点， 从而计算下一个点。
#include <bits/stdc++.h>
using namespace std;
int n;
int r[400][3];   //记录路径
char s[30][30];  //字符数组，记录迷宫
int fx[5] = {0, 0, -1, 0, 1};
int fy[5] = {0, -1, 0, 1, 0};
//打印路径
void show(int k) {
  int i;
  for (i = 1; i <= k; i++) {
    cout << "(" << r[i][1] << "," << r[i][2] << ")";
    //如果不是最后一个点，加->
    if (i != k) {
      cout << "->";
    } else {
      cout << endl;
    }
  }
}
// x y 表示要探测的点， k 表示要存储的路径数组的下标
void fun(int k) {
  int tx, ty;
  for (int i = 1; i <= 4; i++) {
    tx = r[k - 1][1] + fx[i];
    ty = r[k - 1][2] + fy[i];
    if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && s[tx][ty] == '0') {
      r[k][1] = tx;
      r[k][2] = ty;
      s[tx][ty] = '1';
      if (tx == n && ty == n) {
        show(k);
      } else {
        fun(k + 1);
      }
    }
  }
}
int main() {
  cin >> n;
  int i, j;
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      cin >> s[i][j];
    }
  }
  //从 1,1 点开始探测，从下标为 1 开始记录路径
  r[1][1] = 1;
  r[1][2] = 1;
  s[1][1] = '1';  //标记出发点走过
  fun(2);
}