/*1223 - 【入门】汉诺塔的移动次数
题目描述
汉诺塔的问题大家都已经很熟悉了，有三个柱子，每个柱子上有一些大小不一的金片，要把金片从A柱移动到C柱，可以借助B柱，请问n个金片的情况下，需要最少移动多少次？

输入
输入一个整数n代表金片的数量（n<=20）
输出
一个整数，代表n个金片的移动次数

样例
输入
3
输出
7
来源
递归

标签
递归
*/
#include <bits/stdc++.h>
using namespace std;
//递归求解n个金片的移动步数
int fun(int n) {
  //递归的出口
  if (n == 1) {
    return 1;
  } else {
    return fun(n - 1) * 2 + 1;
  }
}
int main() {
  /*
  移动的过程：
  1.先将n-1个金片 (n个金片除了最下面一个以外的金片)从A位置，借助C位置，
  移动到B位置，需要fun(n-1)步 2.将A位置的最下方的一个金片，
  直接移动到C位置，需要1步 3.将B位置的n-1个金片，
  从B位置借助A位置移动到C位置需要fun(n-1)步
  因此得到结论如下:fun(n)=fun(n-1)*2+1
  */
  int n;
  cin >> n;
  cout << fun(n);
}