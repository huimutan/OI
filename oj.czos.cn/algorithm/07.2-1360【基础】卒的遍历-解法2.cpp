/*1360 - 【基础】卒的遍历
题目描述
在一张n*m的棋盘上（如6行7列）的最左上角（1,1）的位置有一个卒。
该卒只能向下或者向右走，且卒采取的策略是先向下，下边走到头就向右，
请问从（1,1）点走到（n,m）点可以怎样走，输出这些走法。

输入
两个整数n，m代表棋盘大小（3≤n≤8,3≤m≤8）

输出
卒的行走路线

样例
输入
3 3
输出
1:1,1->2,1->3,1->3,2->3,3
2:1,1->2,1->2,2->3,2->3,3
3:1,1->2,1->2,2->2,3->3,3
4:1,1->1,2->2,2->3,2->3,3
5:1,1->1,2->2,2->2,3->3,3
6:1,1->1,2->1,3->2,3->3,3
来源
深搜 递归

标签
深搜递归
*/

//解法二：利用r数组存储的上一个点的坐标， 求解下一个点的坐标
#include <bits/stdc++.h>
using namespace std;
//只能向下或者向右走：优先向下，其次向右
int n, m;
int r[20][3];  //存储行走路径
//方向的变化
int fx[3] = {0, 1, 0};
int fy[3] = {0, 0, 1};
int c;  //计数器
void print(int k) {
  c++;
  cout << c << ":";
  //除了最后一个点以外
  for (int i = 1; i < k; i++) {
    cout << r[i][1] << "," << r[i][2] << "->";
  }
  cout << n << "," << m << endl;
}
//向r数组下标为k 的那一行存经过的点的坐标
void dfs(int k) {
  int tx, ty;
  for (int i = 1; i <= 2; i++) {
    //得到新点坐标
    tx = r[k - 1][1] + fx[i];
    ty = r[k - 1][2] + fy[i];
    //判断 tx,ty 有效
    if (tx >= 1 && tx <= n && ty >= 1 && ty <= m) {
      //存储tx,ty
      r[k][1] = tx;
      r[k][2] = ty;
      //如果到了终点，则打印，否则递归
      if (tx == n && ty == m) {
        print(k);
      } else {
        dfs(k + 1);
      }
    }
  }
}
int main() {
  cin >> n >> m;
  //第1个点的坐标直接存入
  r[1][1] = 1;
  r[1][2] = 1;
  //向 r 数组下标为 2 的那一行存坐标
  dfs(2);
}
