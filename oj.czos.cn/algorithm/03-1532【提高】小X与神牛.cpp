/*1532 - 【提高】小X与神牛
题目描述
神牛都长着B只角，B只角从左到右在头顶上排成一排。每只角上都标着数字，不是0就是1。
小X将每头神牛的B只角上的数字从左到右依次取出，组成一个只含0或1的B位二进制数。
小X将这个二进制数转化为十进制，用这个十进制数来代表一头神牛，这个十进制就是这头神牛的编号。
神牛们之间的关系是很微妙的，如果两头神牛的第i只角上的数字不同，则称这两头神牛的第i只角是不一样的。
如果两头神牛不同的角的数目大于等于D，则称这两头神牛是友好的。比如当B=8，D=2时，
01010100
00110100
  xx
这两头神牛的第2和第3只角不同(x指向的位置)，不同的角的数目为2，所以这两头神牛是友好的。
现在小X向你求助：请找出N头神牛，使得任意两头神牛都是友好的，并将这N头神牛的编号按从小到大排序后依次输出。如果有多种符合条件的解，那么排在越前面的牛的编号越小越好。

输入
输入仅有一行包含3个用空格隔开的正整数，分别表示 N, B, D。

输出
输出仅有一行包含N个非负整数，相邻两个数之间用一个空格隔开，表示N头神牛的编号。如果有多解，你的程序要输出这样的解：越前面的牛的编号越小越好。

样例
输入
3 5 3
输出
0 7 25
说明
样例输入
样例1:
3 5 3
样例2:
16 7 3
样例输出
样例1:
0 7 25
样例2:
0 7 25 30 42 45 51 52 75 76 82 85 97 102 120 127
样例解释
每头神牛都长着7只角，若两头神牛不同的角的数目大于等于3，则这两头神牛是友好的。现在要找出16头相互都友好的神牛。
答案是0000000, 0000111, 0011001, 0011110, 0101010, 0101101, 0110011, 0110100,
1001011, 1001100, 1010010, 1010101, 1100001, 1100110, 1111000,
1111111，转化为十进制就是0 7 25 30 42 45 51 52 75 76 82 85 97 102 120 127
数据规模
对于30%的数据，1<=D<=B<=8，1<=N<=3
对于另外10%的数据，D=1
对于另外30%的数据，D=2
对于100%的数据，1<=D<=B<=8, 1<=N<=16
数据保证有解。

来源
常州市2017“信息与未来”夏令营选拔赛

来源
市赛

标签
市赛
*/
#include <bits/stdc++.h>
using namespace std;

/*
本质：
从0开始，找出N个数，N个数转成B位的2进制，
要求任何两个数都有>=D位不同的数。

思路：
1.从0开始将每个符合条件的数转换为B位的2进制存入二维数组
2.循环每个数i，判断是否满足条件：
  i转换为B位的二进制要求和二维数组中已经存储的所有数都有>=D位不同
*/
//存储符合条件的数对应的二进制
// k表示r数组的长度，默认0是符合要求的
int r[20][10], k = 1;
int n, b, d;
//将x转换为b位的二进制，判断和r数组的k个数是否都满足有>=d位的不同
bool check(int x) {
  int t[10] = {0};  //存储x转2进制的结果
  int l = 0;
  while (x != 0) {
    l++;
    t[l] = x % 2;
    x /= 2;
  }
  //循环r数组的k个数
  int c;
  for (int i = 1; i <= k; i++) {
    c = 0;
    for (int j = 1; j <= b; j++) {
      if (t[j] != r[i][j]) c++;
    }
    if (c < d) return false;
  }
  //到这个位置，说明编号为x的数和r数组中的数是友好的
  //将编号为x的数对应的二进制存储到r数组
  k++;
  for (int i = 1; i <= b; i++) {
    r[k][i] = t[i];
  }
  return true;
}

int main() {
  cin >> n >> b >> d;  // n头牛b只角，不同d角表友好
  cout << 0 << " ";    // 0是默认的一个解
  for (int i = 1; k < n; i++) {
    if (check(i)) cout << i << " ";  //判断i是否友好
  }
  return 0;
}
