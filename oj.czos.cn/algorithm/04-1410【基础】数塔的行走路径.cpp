/*1410 - 【基础】数塔的行走路径？
题目描述
有如下所示的数塔，要求从底层走到顶层，若每一步只能走到相邻的结点，要求经过结点的数字之和最大，请问应该如何走，请输出从塔底到塔顶的行走路线，同时计算出经过结点的最大数字和是多少？
（假设本问题中，不存在多条路线从塔底走到塔顶经过结点的数字和都是最大的，也就是本题涉及测试数据得到的路径都是唯一的）
为了方便计算我们将数塔中的值存到如下图所示的二维数组中，该数塔的行走路线将如下图的箭头所示。

输入
输入数据首先包括一个整数整数N(1 <= N <=
100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。
输出
第一行，按照样例输出所示的形式，输出数塔的行走路线。
第二行，输出经过结点的最大数字和。

样例
输入
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
输出
5,2->4,2->3,1->2,1->1,1
30
来源
递推

标签
递推
*/
#include <bits/stdc++.h>
using namespace std;
/*
思路：
第一步：采用逆推法， 计算出走到每个点经过的数字和的最大值 ;
第二步：从第一层开始逐层向下计算（递推）， 算出每个点是从下方来的
还是下方的右侧来的， 将路线记录到数组中
*/
int a[110][110];  //存储数塔， 以及走到每个点的最大和的结果
int r[110][3];    //存储路线
int i, j, n, k;   // k 表示 r 数组的下标
int main() {
  cin >> n;
  //读入数塔
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= i; j++) {
      cin >> a[i][j];
    }
  }
  //计算走到每个点经过的数字最大和
  for (i = n - 1; i >= 1; i--) {
    for (j = 1; j <= i; j++) {
      a[i][j] = a[i][j] + max(a[i + 1][j], a[i + 1][j + 1]);
    }
  }
  //计算路径
  //第一个点，也就是终点，不需要计算
  k = 1;
  r[1][1] = 1;
  r[1][2] = 1;
  //表示当前正在计算的点
  i = 1;
  j = 1;
  //推导第2 行的点是从哪个点上来的， 直到第 n 行，就结束
  while (i < n) {
    k++;
    if (a[i + 1][j] > a[i + 1][j + 1]) {
      r[k][1] = i + 1;
      r[k][2] = j;
      i++;
    } else {
      r[k][1] = i + 1;
      r[k][2] = j + 1;
      i++;
      j++;
    }
  }
  //逆序从底到顶打印路线
  for (i = k; i >= 1; i--) {
    cout << r[i][1] << "," << r[i][2];
    //除了第 1 行以外，都有->
    if (i != 1) {
      cout << "->";
    }
  }
  cout << endl << a[1][1];
}