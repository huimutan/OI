/*1430 - 【基础】迷宫出口
题目描述
一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由n *
n的格点组成， 每个格点只有2种状态，0和1，前者表示可以通行后者表示不能通行。
同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，
Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。如果起点或者终点有一个不能通行(为1)，则看成无法办到。

输入
第1行是一个正整数n (1 ≤ n ≤ 100)，表示迷宫的规模是n * n的。
接下来是一个n * n的矩阵，矩阵中的元素为0或者1。
再接下来一行是4个整数ha la hb lb，描述A处在第ha行 第la列，B处在第hb行 第lb列。

输出
能办到则输出“YES”，否则输出“NO”。

样例
输入
3
0 1 1
0 0 1
1 0 0
1 1 3 3
输出
YES
来源
深搜 递归 广搜

标签
深搜递归广搜
*/
#include <bits/stdc++.h>
using namespace std;
/*
0表示可以走，1表示不能走
博
如果起点或者终点有一个是 1，也视为不可达
*/
int a[110][110];
// s1,s2:代表出发点，e1,e2:代表结束点
int n, s1, s2, e1, e2;
//沿：右、下、左、上四方向依次递归
int fx[5] = {0, 0, 1, 0, -1};
int fy[5] = {0, 1, 0, -1, 0};
bool f = false;  //假设走不到终点
//深搜：逐个遍历每个点， 看是否能探索到结束点
void dfs(int x, int y) {
  a[x][y] = 1;  //将走过的点标记为 1, 防止死循环
  int tx, ty;   //表示将要去探索的点
  for (int i = 1; i <= 4; i++) {
    tx = x + fx[i];
    ty = y + fy[i];
    //判断新点是否有效(没有访问过， 且没有出边界)
    if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && a[tx][ty] == 0) {
      //判断要去的点是否是终点
      if (tx == e1 && ty == e2) {
        f = true;
      } else {
        dfs(tx, ty);
      }
    }
  }
}
int main() {
  cin >> n;
  int i, j;
  //读入迷宫
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      cin >> a[i][j];
    }
  }
  //读入起止点
  cin >> s1 >> s2 >> e1 >> e2;
  //如果起止点有不可达的情况不需要递归
  if (a[s1][s2] == 1 || a[e1][e2] == 1) {
    cout << "NO";
  } else {
    dfs(s1, s2);
    //找到终点
    if (f == true) {
      cout << "YES";
    } else {
      cout << "NO";
    }
  }

  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      cout << a[i][j] << " ";
    }
    cout << endl;
  }
}