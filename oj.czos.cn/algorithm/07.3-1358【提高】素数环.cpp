/*1358 - 【提高】素数环
题目描述
从1~n（2<=n<=10）这n个数，摆成一个环，要求相邻的两个数的和是素数，按照由小到大请输出所有可能的摆放形式。

比如：n = 4，输出形式如下

1:1 2 3 4

2:1 4 3 2
3:2 1 4 3
4:2 3 4 1
5:3 2 1 4
6:3 4 1 2
7:4 1 2 3
8:4 3 2 1
total:8

比如：n = 6，输出形式如下

1:1 4 3 2 5 6
2:1 6 5 2 3 4
3:2 3 4 1 6 5
4:2 5 6 1 4 3
5:3 2 5 6 1 4
6:3 4 1 6 5 2
7:4 1 6 5 2 3
8:4 3 2 5 6 1
9:5 2 3 4 1 6
10:5 6 1 4 3 2
11:6 1 4 3 2 5
12:6 5 2 3 4 1
total:12

输入
一个整数n（2<=n<=10）

输出
前若干行，每行输出一个素数环的解，最后一行，输出解的总数

样例
输入
4
输出
1:1 2 3 4
2:1 4 3 2
3:2 1 4 3
4:2 3 4 1
5:3 2 1 4
6:3 4 1 2
7:4 1 2 3
8:4 3 2 1
total:8
来源
回溯

标签
回溯排列组合
*/
#include <bits/stdc++.h>
using namespace std;
/*
将n 个数全排列，且要求相邻的数的和是素数
（第一个数和最后一个数算相邻）
思路：从1~n 中， 选数填到 a 数组的下标为k的位置
从 k=1 开始填写，直到 k==n，也就是 a数组填满
填写的过程中， 要求相邻的数的和是素数
*/
int a[20];   //存放选数的结果
bool f[20];  //标记每个数是否被用过
int n, c;
//素数判断
bool prime(int n) {
  for (int i = 2; i * i <= n; i++) {
    if (n % i == 0) {
      return false;
    }
  }
  if (n == 1) return false;
  return true;
}
//输出结果
void print() {
  c++;
  cout << c << ":";
  for (int i = 1; i <= n; i++) {
    cout << a[i];
    if (i != n) {
      cout << " ";
    } else {
      cout << endl;
    }
  }
}
//递归选数的函数
void fun(int k) {
  //下标为k的位置，有 n 种选法
  for (int i = 1; i <= n; i++) {
    //如果 i 没有被选过，且 i 和前一个数的和是素数
    //&&:如果第 1 条件为 false, 第 2 条件不判断，结果直接为 false
    //||:如果第 1 条件为 true, 第 2 条件不判断，结果直接为 true
    if (f[i] == false && (k == 1 || prime(i + a[k - 1]) == true)) {
      a[k] = i;     //将选中的数填入数组
      f[i] = true;  //标记 i 用过了
      //如果元素的数量足够了， 且最后一个数和第一个数的和是素数， 则打印
      if (k == n && prime(a[k] + a[1])) {
        print();
      } else {
        //递归向 k+1 的位置存值
        fun(k + 1);
      }
      //回溯：撤销 i 用过的标记
      f[i] = false;
    }
  }
}
int main() {
  cin >> n;
  //从 a 数组下标为 1 的位置开始选数
  fun(1);
  cout << "total:" << c;
}