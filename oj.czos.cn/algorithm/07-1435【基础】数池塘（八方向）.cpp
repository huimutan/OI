/*1435 - 【基础】数池塘（八方向）
题目描述
农夫约翰的农场可以表示成N*M（1≤N≤100≤M≤100）个方格组成的矩形。由于近日的降雨，在约翰农场上的不同地方形成了池塘。每一个方格或者有积水（'W'）或者没有积水（'.'）。农夫约翰打算数出他的农场上共形成了多少池塘。一个池塘是一系列相连的有积水的方格，每一个方格周围的八个方格都被认为是与这个方格相连的。现给出约翰农场的图样，要求输出农场上的池塘数。

输入
第1行：由空格隔开的两个整数：N和M
第2..N+1行：每行M个字符代表约翰农场的一排方格的状态。每个字符或者是'W'或者是'.'，字符之间没有空格。

输出
输出只有1行，输出约翰农场上的池塘数

样例
输入
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
输出
3
来源
深搜 递归 广搜

标签
深搜递归广搜
*/
#include <bits/stdc++.h>
using namespace std;
int n, m;
char a[101][101];
int fx[8] = {-1, 0, 1, 0, -1, -1, 1, 1};
int fy[8] = {0, 1, 0, -1, -1, 1, 1, -1};
void dfs(int i, int j) {
  //标记为点
  a[i][j] = '.';
  int oi, oj, k;
  for (k = 0; k < 8; k++) {
    oi = i + fx[k];
    oj = j + fy[k];
    // (i-1,0)  (i,j+1) (i+1,j) (i,j-1)
    if (oi >= 1 && oi <= n && oj >= 1 && oj <= m && a[oi][oj] == 'W') {
      dfs(oi, oj);
    }
  }
}

int main() {
  cin >> n >> m;
  int i, j, c = 0;
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= m; j++) {
      cin >> a[i][j];
    }
  }

  for (i = 1; i <= n; i++) {
    for (j = 1; j <= m; j++) {
      if (a[i][j] == 'W') {
        dfs(i, j);
        c++;
      }
    }
  }
  cout << c;
  return 0;
}