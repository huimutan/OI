 



# 16、数组进阶  

## 一、数组排序

#### 1010:【入门】数组元素的排序

**冒泡排序：**

`n=4` 

`int a[4] = {4 3 2 1}` 

第1轮：下标0~n-1的数参加排序，但循环下标0~n-2,比较a[j]和a[j+1]
a[0]>a[1],交换：3**`4`**21
a[1]>a[2],交换：32**`4`**1
a[2]>a[3],交换：321**`4`**
第2轮：下标0~n-2的数参加排序，但循环下标0~n-3,比较a[j]和a[j+1]
a[0]>a[1],交换：2**`3`**14
a[1]>a[2],交换：21**`3`**4
第3轮：下标0~n-3的数参加排序，但循环下标0~n-4,比较a[j]和a[j+1]
a[0]>a[1],交换：1**`2`**34
**总结归纳（归纳法）**
(1)n个数排序n-1轮（循环用i表示排序轮数，i=1~n-1）
(2)第i轮，用j循环下标为**0**的数到下标为**n-i-1**的数，如果a[j]>a[j+1],
交换它们

```cpp
/*1010 - 【入门】数组元素的排序
题目描述
对数组的元素按从小到大进行排序。

输入
有两行 第一行有一个整数n( 5 <= n <= 10 ) 第二行有n个整数
输出
输出更新后的数组

样例
输入
8
1 2 3 6 8 7 4 5
输出
1 2 3 4 5 6 7 8
来源
数组问题
标签
数组问题
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  int a[20], i, j, n, t;
  cin >> n;  //读入数组元素
  for (i = 0; i < n; i++) {
    cin >> a[i];
  }
  //排序
  //循环i代表排序的轮数(i在此处代表排序的轮数)
  // n个数排序n-1轮
  for (i = 1; i <= n - 1; i++) {
    //第i轮排序，需要下标为0~n-i的数参加排序
    //循环范围：0~n-i-l,如果前一个数 > 后一个数，交换它们
    //此处j代表的是数组元素的下标
    for (j = 0; j <= n - i - 1; j++) {
      if (a[j] > a[j + 1]) {
        t = a[j];
        a[j] = a[j + 1];
        a[j + 1] = t;
      }
    }
  }
  //输出排序的结果
  for (i = 0; i < n; i++) {
    cout << a[i] << " ";
  }
  return 0;
}

```



1166：**【基础】数的排序**

```cpp
/*1166 - 【基础】数的排序
题目描述
输入n个不超过30000的整数（n≤10）。然后求出每个数的数字和，再按每个数的数字和由小到大排列输出。

输入
第一行为整数n
第二行为n个整数
输出
由小到大排列的每个数的数字和（每个数之间保留一个空格）

样例
输入
4
33 104 87 16
输出
5 6 7 15
来源
数组问题
标签
数组问题
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  /*思路：读入数组元素，求出每个数的各个位的和
  然后对各个位的和进行排序
*/

  int n, a[20], i, j, t, s;
  cin >> n;
  for (i = 0; i < n; i++) {
    cin >> a[i];
    //求出的各个位的和，替换a[i]的值
    s = 0;
    while (a[i] != 0) {
      s += a[i] % 10;  //得到个位，将个位加到总和
      a[i] /= 10;      //去除个位
    }
    // cout << s << " ";  //测试求和是否正确
    a[i] = s;  //用求出的和替换原来的值
  }
  //排序：n个数排序n - 1轮
  // i代表排序的轮数
  for (i = 1; i <= n - 1; i++) {
    //第i轮从下标为0的元素循环到下标为n - i -1的元素
    for (j = 0; j <= n - i - 1; j++) {
      //如果当前数 > 后面的元素，交换
      if (a[j] > a[j + 1]) {
        t = a[j];
        a[j] = a[j + 1];
        a[j + 1] = t;
      }
    }
  }
  //输出排序的结果
  for (i = 0; i < n; i++) {
    cout << a[i] << " ";
  }
  return 0;
}
```



#### 1175:【入门】语文成绩

```cpp
/*1175 - 【入门】语文成绩
题目描述
给出N(5 <= N
<=150)个人的语文成绩，求N个人的语文总分和平均分，并按成绩高低排序后输出。

输入
第1行：一个整数N。 第2行：空格隔开的N个整数，表示N个人的语文成绩。
输出
三行。

第1行：一个整数，为N个人的总分。
第2行：N个人的语文平均分，保留两位小数。
第3行：N个空格隔开的整数，为从高到低输出的N个人的成绩。

样例
输入
5
72 98 95 81 86
输出
432
86.40
98 95 86 81 72
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n;
  cin >> n;
  int a[n], sum = 0;
  for (int i = 0; i < n; i++) {
    cin >> a[i];
    sum += a[i];
  }
  for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
      if (a[j] < a[j + 1]) {
        int t = a[j];
        a[j] = a[j + 1];
        a[j + 1] = t;
      }
    }
  }
  cout << sum << endl;
  cout << fixed << setprecision(2) << sum * 1.0 / n << endl;
  for (int i = 0; i < n; i++) {
    cout << a[i] << " ";
  }
  return 0;
}

```



#### 1233:【入门】求中位数

```cpp
/*1233 - 【入门】求中位数
题目描述
中位数指的是一组数，如果按照大小排序排好后最中间的那个数的值，如果有偶数个元素，那么就是最中间两个数的平均数！
比如：2 5 8 1 6，排序后的结果为1 2 5 6 8，那么这组数的中位数就是5！
再比如：8 9 1 2 3 0，排序后的结果为0 1 2 3 8
9，那么这组书的中位数就是(2+3)/2=2.5

输入
第一行：一个整数n代表有n个数（n≤100）
第二行：n个数的值
输出
中位数（结果保留1位小数）

样例
输入
5
2 5 8 1 6
输出
5.0
*/

// n= 5
//下标：0 1 2 3 4,中位数下标：n / 2
// n=6
//下标：0 1 2 3 4 5,中位数下标：n/2 - 1, n / 2

#include <bits/stdc++.h>
using namespace std;
int main() {
  //思路：先对数组元素排序，然后判断奇偶，找出中位数
  int n, a[1000], i, j, t;
  double v;  //存放中位数
  cin >> n;
  for (i = 0; i < n; i++) {
    cin >> a[i];
  }
  //对数组元素按照由小到大进行排序
  for (i = 1; i < n; i++) {  // i代表排序的轮数
    //第i轮从下标为0的数，排序到下标为n-i (循环到n-i-1)
    for (j = 0; j <= n - i - 1; j++) {
      if (a[j] > a[j + 1]) {
        t = a[j];
        a[j] = a[j + 1];
        a[j + 1] = t;
      }
    }
  }
  // for(i = 0;i <n;i++){
  // cout<<a[i]<<M
  // }
  //得到中位数
  if (n % 2 != 0) {
    v = a[n / 2];
  } else {
    v = (a[n / 2] + a[n / 2 - 1]) / 2.0;
  }
  cout << fixed << setprecision(1) << v << endl;
  return 0;
}

```



二、作业

1172:【入门】寻找第K大数

1221:【入门】优秀成绩的平均分

1242:【基础】第K大与第K小数

1399:【入门】学员的名次？ 附加题：

1326:【入门】需要安排几位师傅加工零件?



## 三、利用数组存放运算结果

1178:**【入门】**COUNT

注意：学会使用数组存放运算的结果！

思路：准备长度为10的数组，分别存放0~9出现的次数，下标为0的位置存放0出现的次数，下标为1的位置存放1出现的次数，以此类推！

循环每个页码，拆出每个页码的每一位，找到对应的数组下标，自增下标中存放的数！

| 元素a[i] | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 下标i    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |

 

```cpp
/*1178 - 【入门】COUNT
题目描述
一本书的页数为N，页码从1开始编起，请你求出全部页码中，用了多少个0，1，2……9。

输入
一个正整数N（N<=10000），表示总的页码。
输出
共十行：第k行为数字k-1的个数。

样例
输入
11
输出
1
4
1
1
1
1
1
1
1
1
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  /*思路：循环1~n的每个数，拆出每个数的每一位
  分别统计0~9出现的次数*/
  int n, a[10] = {0};  // n页码
  cin >> n;
  for (int i = 1; i <= n; i++) {  //循环1~n的每个页码
    //用短除法，拆出i的每一位
    int x = i;  //过渡一下，不能直接拆i,否则死循环
    while (x != 0) {
      a[x % 10]++;
      x /= 10;
    }
  }
  //输出中所有的页码用了多少0~9。
  for (int i = 0; i < 10; i++) cout << a[i] << endl;
  return 0;
}

```



#### 1180:【入门】数字出现次数

```
题目描述
有50个数（0-19），求这50个数中相同数字出现的最多次数为几次？
```

| 元素a[i] |      | 2    | 2    | 1    | 1    |      |      | 1    |      |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 下标i    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | ...  |

> 思路：准备一个长度为20的数组，下标为i就存放i那个数出现的次数！由于数组存储的是每个数出现的次数，因此数组的最大数就是出现次数最多的数出现的次数(下标就是出现次数最多的数)。

1 2 8 7 2 3 1 4 读入的50个元素分别是：a[i],下标为a[i]的c数组的元素都要自增， 

实现思路一：用a数组存储50个元素，用c数组存储每个元素出现的次数! 

```cpp
  //存放每个元素
  int a[50];
  //用来存放每个数出现的次数
  int c[20] = {0};
  int i, m;  // m用来求最多的次数(c数组的最大值)
  //读入50个数
  for (i = 0; i < 50; i++) {
    cin >> a[i];
    //下标为a[i]的c数组的元素要自增
    c[a[i]]++;
  }
  //求最多出现的次数(c数组的最大数)
  m = c[0];
  for (i = 1; i < 20; i++) {
    if (c[i] > m) m = c[i];
  }
  cout << m << endl;
```



实现思路二：读入50个元素，可以不用数组，可以用一个整数变量，每读入一个数，就计数一次(记录该数出现的次数要自增1)

```cpp
  //存放每个元素
  int x;
  //用来存放每个数出现的次数
  int c[20] = {0};
  int i, m;  // m用来求最多的次数(c数组的最大值)
  //读入50个数
  for (i = 0; i < 50; i++) {
    cin >> x;
    //下标为x的c数组的元素要自增
    c[x]++;
  }
  //求最多出现的次数(c数组的最大数)
  m = c[0];
  for (i = 1; i < 20; i++) {
    if (c[i] > m) m = c[i];
  }
  cout << m << endl;
```

改进思路二：

```cpp
  int x, m = 0, c[20] = {0};
  for (int i = 0; i < 50; i++) {
    cin >> x;
    c[x]++;
    if (c[x] > m) m = c[x];
  }
  cout << m;
```



#### 1183:【基础】去除重复数字

思路一：每读入一个元素x,就在数组中循环一遍(循环数组的k个数，下标(0~k-1),看看

数组a中有没有*x*这个数， 如果有，就不存入数组 a,如果没有，就把x存入数组 a 。


| 元素a[i] | 7 | 9 | 8 |      |      |         |  |      |      |         |
| ------------------------ | -------------------- | ------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------- |
| 下标i    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | ....... |

 

```cpp
/*1183 - 【基础】去除重复数字
题目描述
给你N个数（n≤100）,每个数都在（0~1000）之间，其中由很多重复的数字，请将重复的数字只保留一个，并将剩下的数由小到大排序并输出。

输入
输入有2行，
第1行为1个正整数，表示数的个数:N
第2行有N个用空格隔开的整数。

输出
第1行为1个正整数M，表示不相同数的个数。
接下来的M行，每行一个整数，表示从小到大排好序的不相同的数。

样例
输入
10
20 40 32 67 40 20 89 300 400 15
输出
8
15
20
32
40
67
89
300
400
来源
数组问题

标签
数组问题
*/
#include <bits/stdc++.h>
using namespace std;
int main() {
  /*
  思路：去除重复的元素，对剩余的元素进行排序
  去除重复方法一：读入每个元素都判断一下数组中是否存在该元素
  如果存在就不存入数组，如果不存在再存储
  */
  int i, n, a[110], x, j, t;
  bool f;     //用来标记读入的元素是否出现过
  int k = 0;  //表示目前数组中实际不重复的元素个数
  cin >> n;
  // i代表将要读入n个数，相当于是一个计数器
  for (i = 0; i < n; i++) {
    cin >> x;
    //判断×在a数组中是否存在(a数组有k个元素)
    f = false;  //假设a数组中没有元素x
    //循环a数组的k个元素
    for (j = 0; j < k; j++) {
      if (a[j] == x) {
        f = true;
        break;  //停止当前循环
      }
    }
    //如果数组a中没有元素x,则将x存入数组
    if (f == false) {
      a[k] = x;
      k++;
    }
  }
  //排序
  for (i = 1; i < k; i++) {
    for (j = 0; j <= k - i - 1; j++) {
      if (a[j] > a[j + 1]) {
        t = a[j];
        a[j] = a[j + 1];
        a[j + 1] = t;
      }
    }
  }
  //输出
  cout << k << endl;
  for (i = 0; i < k; i++) {
    cout << a[i] << endl;
  }
}
```



思路二：通过长度为1001的标记数组f来标记某个数是否出现过，判断X是否出现过，通过判断f[x]是否为0来判断，如果f[x]==0,认为没有出现过，则将X存入数组a,同时将 f [x]标记为1。

f数组：标记数组

| 0    | 0    | 1    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | …    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | …    | 1001 |

| 元素a[i] | 8    | 9    | 7    | 2    |      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 下标i    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | ……   |

x = 8978282

```cpp
  /*
思路：去除重复的元素，对剩余的元素进行排序
去除重复方法二：由于读入的元素在0~1000之间，我们准备一个长度为1001的数组
用来标记有没有出现过
*/
  int i, n, a[110], x, j, t;
  int f[1001] = {0};  //标记数组
  int k = 0;          //表示目前数组中实际不重复的元素个数
  cin >> n;
  // i代表将要读入n个数，相当于是一个计数器
  for (i = 0; i < n; i++) {
    cin >> x;
    //如果数组a中没有元素x,则将x存入数组
    if (f[x] == 0) {
      a[k] = x;
      k++;
      //修改标记，标记×出现了
      f[x] = 1;
    }
  }
  //排序
  for (i = 1; i < k; i++) {
    for (j = 0; j <= k - i - 1; j++) {
      if (a[j] > a[j + 1]) {
        t = a[j];
        a[j] = a[j + 1];
        a[j + 1] = t;
      }
    }
  }
  //输出
  cout << k << endl;
  for (i = 0; i < k; i++) {
    cout << a[i] << endl;
  }
```



**思路三：其实本题一旦用数组标记哪些数出现过之后，也就不需要再排序了，可以自己先思**

**考一下为什么，再看下面的程序！**

```cpp
  //用来统计哪些数出现了
  int a[1001] = {0};
  int n, x, i, c = 0;
  cin >> n;
  for (i = 0; i < n; i++) {
    cin >> x;  //读入n个数
    //如果x没有出现过
    if (a[x] == 0) {
      c++;
    }
    a[x] = 1;  //标记出现过
  }
  cout << c << endl;
  //输出不重复的数
  //也就是数组中非0元素的下标
  for (i = 0; i < 1001; i++) {
    //输出非0下标
    if (a[i] == 1) {
      cout << i << endl;
    }
  }
```



## 四、数组存放结果作业

#### 1179:【入门】求N个整数的平均数、众数和中位数

#### 1252:【基础】邮票组合

#### 1334:【基础】扑克牌组合

